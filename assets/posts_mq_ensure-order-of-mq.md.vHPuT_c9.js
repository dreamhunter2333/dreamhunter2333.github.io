import{_ as e,c as a,o as t,aj as r}from"./chunks/framework.Cy5U5pv3.js";const q=JSON.parse('{"title":"保证消息的顺序性","description":"","frontmatter":{"title":"保证消息的顺序性","date":"2021-03-17 22:40:29","categories":["mq"],"tags":["mq"]},"headers":[],"relativePath":"posts/mq/ensure-order-of-mq.md","filePath":"posts/mq/ensure-order-of-mq.md","lastUpdated":1720265245000}'),o={name:"posts/mq/ensure-order-of-mq.md"},s=r('<h1 id="保证消息的顺序性" tabindex="-1">保证消息的顺序性 <a class="header-anchor" href="#保证消息的顺序性" aria-label="Permalink to &quot;保证消息的顺序性&quot;">​</a></h1><h2 id="场景" tabindex="-1">场景 <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景&quot;">​</a></h2><p>先看看顺序会错乱的俩场景：</p><ul><li>RabbitMQ：一个 queue，多个 consumer</li><li>Kafka：一个 topic，有三个 partition, 多个线程来并发处理消息</li></ul><h2 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h2><ul><li>RabbitMQ：拆分多个 queue，每个 queue 一个 consumer</li><li>Kafka：写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；N 个线程，每个线程分别消费一个内存 queue</li></ul>',6),i=[s];function l(n,u,c,d,_,m){return t(),a("div",null,i)}const p=e(o,[["render",l]]);export{q as __pageData,p as default};
