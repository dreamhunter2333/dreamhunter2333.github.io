import{_ as e,c as s,o as t,aj as a}from"./chunks/framework.Cy5U5pv3.js";const l=JSON.parse('{"title":"fast redis zset","description":"","frontmatter":{"title":"fast redis zset","date":"2020-11-25 21:40:37","categories":"redis","tags":["redis"]},"headers":[],"relativePath":"posts/redis/fast-redis-zset.md","filePath":"posts/redis/fast-redis-zset.md","lastUpdated":1720265684000}'),r={name:"posts/redis/fast-redis-zset.md"},i=a('<h1 id="fast-redis-zset" tabindex="-1">fast redis zset <a class="header-anchor" href="#fast-redis-zset" aria-label="Permalink to &quot;fast redis zset&quot;">​</a></h1><h2 id="fast-redis-zset-1" tabindex="-1">fast redis zset <a class="header-anchor" href="#fast-redis-zset-1" aria-label="Permalink to &quot;fast redis zset&quot;">​</a></h2><p>redis支持一个数据结构，叫做 zset，也就是有序的列表。</p><p>通过它，可以实现游戏排行榜一类的功能，或者实现Topx这样的需求，也能精准的让用户在海量数据中找到自己的位置。</p><p>zset的底层结构是跳跃表，而与之类似的Java中的有序Set是TreeSet，使用红黑树实现的。</p><p>我们的问题是：zset中能存放多少条记录？线上有没有有说服力的数据？</p><p>先笼统的回答一下，zset理论上支持的元素最多是2^32-1个，约42亿，如果你的内存够大，放下国人绰绰有余。</p><p>在测试的zset里，存放了接近6千万的数据，我们就要算在这6千万内任何的排行。zcard、zrank等一系列操作，easy实现。</p><p>运行一段时间后，内存直接飙升到了8G左右。这是由于跳表的特殊结构所引起的，额外的辅助信息会占用更多的内存。</p><p>以下是经验值：</p><p>最高TPS写入量1k/秒。 同时最高QPS查询量5k/秒。 平均耗时5ms左右。 百分之95的请求都在10ms以内返回。 长尾请求超过100ms的不超过100条。 也就是说，在保持高写入和高查询的同时，zset能够保证较低的响应耗时。</p><p><a href="https://zhuanlan.zhihu.com/p/153047528?utm_source=wechat_session" target="_blank" rel="noreferrer">参考链接</a></p>',12),d=[i];function o(p,n,_,c,f,z){return t(),s("div",null,d)}const m=e(r,[["render",o]]);export{l as __pageData,m as default};
