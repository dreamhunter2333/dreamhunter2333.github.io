import{_ as t,c as e,o as a,aj as o}from"./chunks/framework.q8cpVy6V.js";const h=JSON.parse('{"title":"Mysql 关键字执行顺序","description":"","frontmatter":{"title":"Mysql 关键字执行顺序","date":"2021-06-07 19:36:38","categories":["database"],"tags":["database"]},"headers":[],"relativePath":"posts/database/SQL-keyword-order.md","filePath":"posts/database/SQL-keyword-order.md","lastUpdated":1720158211000}'),i={name:"posts/database/SQL-keyword-order.md"},r=o('<h1 id="mysql-关键字执行顺序" tabindex="-1">Mysql 关键字执行顺序 <a class="header-anchor" href="#mysql-关键字执行顺序" aria-label="Permalink to &quot;Mysql 关键字执行顺序&quot;">​</a></h1><ol><li>FROM：对FROM子句中前两个表执行笛卡尔积生成虚拟表vt1</li><li>ON: 对vt1表应用ON筛选器只有满足 join_condition 为真的行才被插入vt2</li><li>OUTER(JOIN)：如果指定了 OUTER JOIN保留表(preserved table)中未找到的行将行作为外部行添加到vt2，生成t3，如果 from 包含两个以上表，则对上一个联结生成的结果表和下一个表重复执行步骤。</li><li>WHERE：对vt3应用 WHERE 筛选器只有使 where_condition 为true的行才被插入vt4</li><li>GROUP BY：按GROUP BY子句中的列列表对vt4中的行分组生成vt5</li><li>CUBE|ROLLUP：把超组(supergroups)插入vt6，生成vt6</li><li>HAVING：对vt6应用HAVING筛选器只有使 having_condition 为true的组才插入vt7</li><li>SELECT：处理select列表产生vt8</li><li>DISTINCT：将重复的行从vt8中去除产生vt9</li><li>ORDER BY：将vt9的行按order by子句中的列列表排序生成一个游标vc10</li></ol>',2),s=[r];function l(d,_,n,c,v,p){return a(),e("div",null,s)}const m=t(i,[["render",l]]);export{h as __pageData,m as default};
