import{_ as t,c as e,o as a,aj as l}from"./chunks/framework.Cy5U5pv3.js";const y=JSON.parse('{"title":"为什么使用消息队列","description":"","frontmatter":{"title":"为什么使用消息队列","date":"2021-03-14 18:22:55","categories":["mq"],"tags":["mq"]},"headers":[],"relativePath":"posts/mq/why-mq.md","filePath":"posts/mq/why-mq.md","lastUpdated":1720265684000}'),i={name:"posts/mq/why-mq.md"},d=l('<h1 id="为什么使用消息队列" tabindex="-1">为什么使用消息队列 <a class="header-anchor" href="#为什么使用消息队列" aria-label="Permalink to &quot;为什么使用消息队列&quot;">​</a></h1><h2 id="参考原文" tabindex="-1">参考原文 <a class="header-anchor" href="#参考原文" aria-label="Permalink to &quot;参考原文&quot;">​</a></h2><p><a href="https://doocs.github.io/advanced-java/#/./docs/high-concurrency" target="_blank" rel="noreferrer">原文</a></p><h2 id="消息队列优点和缺点" tabindex="-1">消息队列优点和缺点 <a class="header-anchor" href="#消息队列优点和缺点" aria-label="Permalink to &quot;消息队列优点和缺点&quot;">​</a></h2><p>优点：解耦、异步、削峰</p><ul><li>解耦: 通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，就可以跟其它系统彻底解耦了</li><li>异步: 用户几乎是无感知的</li><li>削峰: 高峰期抗住压力</li></ul><p>缺点</p><ul><li>系统可用性降低: 系统引入的外部依赖越多，越容易挂掉</li><li>系统复杂度提高: 重复消费，消息丢失</li><li>一致性问题: 系统间不一致</li></ul><h2 id="kafka、activemq、rabbitmq、rocketmq-优缺点" tabindex="-1">Kafka、ActiveMQ、RabbitMQ、RocketMQ 优缺点 <a class="header-anchor" href="#kafka、activemq、rabbitmq、rocketmq-优缺点" aria-label="Permalink to &quot;Kafka、ActiveMQ、RabbitMQ、RocketMQ 优缺点&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th style="text-align:left;">ActiveMQ</th><th style="text-align:left;">RabbitMQ</th><th style="text-align:left;">RocketMQ</th><th style="text-align:center;">Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td style="text-align:left;">万级，比 RocketMQ、Kafka 低一个数量级</td><td style="text-align:left;">同 ActiveMQ</td><td style="text-align:left;">10 万级，支撑高吞吐</td><td style="text-align:center;">10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td style="text-align:left;"></td><td style="text-align:left;"></td><td style="text-align:left;">topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td style="text-align:center;">topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td style="text-align:left;">ms 级</td><td style="text-align:left;">微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td style="text-align:left;">ms 级</td><td style="text-align:center;">延迟在 ms 级以内</td></tr><tr><td>可用性</td><td style="text-align:left;">高，基于主从架构实现高可用</td><td style="text-align:left;">同 ActiveMQ</td><td style="text-align:left;">非常高，分布式架构</td><td style="text-align:center;">非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td style="text-align:left;">有较低的概率丢失数据</td><td style="text-align:left;">基本不丢</td><td style="text-align:left;">经过参数优化配置，可以做到 0 丢失</td><td style="text-align:center;">同 RocketMQ</td></tr><tr><td>功能支持</td><td style="text-align:left;">MQ 领域的功能极其完备</td><td style="text-align:left;">基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td style="text-align:left;">MQ 功能较为完善，还是分布式的，扩展性好</td><td style="text-align:center;">功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><ul><li>不推荐用 ActiveMQ</li><li>RabbitMQ erlang 开源的，稳定支持，活跃度高</li><li>RocketMQ: 阿里出品(已捐给 Apache)，有突然黄掉的风险</li><li>大数据领域, 日志 Kafka</li></ul>',11),r=[d];function n(s,c,o,h,f,g){return a(),e("div",null,r)}const b=t(i,[["render",n]]);export{y as __pageData,b as default};
