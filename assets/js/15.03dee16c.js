(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{743:function(t,v,e){"use strict";e.r(v);var i=e(47),l=Object(i.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("ol",[e("li",[t._v("FROM：对FROM子句中前两个表执行笛卡尔积生成虚拟表vt1")]),t._v(" "),e("li",[t._v("ON: 对vt1表应用ON筛选器只有满足 join_condition 为真的行才被插入vt2")]),t._v(" "),e("li",[t._v("OUTER(JOIN)：如果指定了 OUTER JOIN保留表(preserved table)中未找到的行将行作为外部行添加到vt2，生成t3，如果 from 包含两个以上表，则对上一个联结生成的结果表和下一个表重复执行步骤。")]),t._v(" "),e("li",[t._v("WHERE：对vt3应用 WHERE 筛选器只有使 where_condition 为true的行才被插入vt4")]),t._v(" "),e("li",[t._v("GROUP BY：按GROUP BY子句中的列列表对vt4中的行分组生成vt5")]),t._v(" "),e("li",[t._v("CUBE|ROLLUP：把超组(supergroups)插入vt6，生成vt6")]),t._v(" "),e("li",[t._v("HAVING：对vt6应用HAVING筛选器只有使 having_condition 为true的组才插入vt7")]),t._v(" "),e("li",[t._v("SELECT：处理select列表产生vt8")]),t._v(" "),e("li",[t._v("DISTINCT：将重复的行从vt8中去除产生vt9")]),t._v(" "),e("li",[t._v("ORDER BY：将vt9的行按order by子句中的列列表排序生成一个游标vc10")])])])}),[],!1,null,null,null);v.default=l.exports}}]);